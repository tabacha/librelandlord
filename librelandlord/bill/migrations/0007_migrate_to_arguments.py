# Generated by Django 5.2.9 on 2025-12-31 15:48

from django.db import migrations


def migrate_arguments_forward(apps, schema_editor):
    """Migriert die alten argument1/2/3 Felder in das neue ConsumptionCalcArgument Model

    Wichtig: Wenn argument3 vorhanden ist, wird eine verschachtelte Berechnung erstellt,
    um die alte Semantik (A op1 B) op2 C zu erhalten.
    Im neuen System würde sonst Punkt-vor-Strich angewendet werden!
    """
    ConsumptionCalc = apps.get_model('bill', 'ConsumptionCalc')
    ConsumptionCalcArgument = apps.get_model('bill', 'ConsumptionCalcArgument')

    for calc in ConsumptionCalc.objects.all():
        # Prüfe ob argument3 vorhanden ist
        has_arg3 = calc.argument3 or calc.argument3_value is not None

        if has_arg3:
            # Fall: 3 Argumente -> Erstelle verschachtelte Berechnung
            # Alt: (arg1 op1 arg2) op2 arg3
            # Neu: SubCalc(arg1 op1 arg2) op2 arg3

            # 1. Erstelle Sub-Berechnung für arg1 op1 arg2
            sub_calc = ConsumptionCalc.objects.create(
                name=f"{calc.name} [FIXME: arg1+arg2]",
                operator=calc.operator1 if calc.operator1 and calc.operator1 != ' ' else '+',
                start_date=calc.start_date,
                end_date=calc.end_date
            )

            # Argument 1 in Sub-Calc
            if calc.argument1 or calc.argument1_value is not None:
                ConsumptionCalcArgument.objects.create(
                    consumption_calc=sub_calc,
                    position=1,
                    meter_place=calc.argument1,
                    value=calc.argument1_value,
                    unit=calc.argument1_unit or '',
                    explanation=calc.argument1_explanation or ''
                )

            # Argument 2 in Sub-Calc
            if calc.argument2 or calc.argument2_value is not None:
                ConsumptionCalcArgument.objects.create(
                    consumption_calc=sub_calc,
                    position=2,
                    meter_place=calc.argument2,
                    value=calc.argument2_value,
                    unit=calc.argument2_unit or '',
                    explanation=calc.argument2_explanation or ''
                )

            # 2. Setze operator2 als Haupt-Operator
            calc.operator = calc.operator2 if calc.operator2 and calc.operator2 != ' ' else '+'
            calc.save(update_fields=['operator'])

            # 3. Erstelle Arguments für Haupt-Calc: SubCalc op2 arg3
            # Argument 1: nested_calc
            ConsumptionCalcArgument.objects.create(
                consumption_calc=calc,
                position=1,
                nested_calc=sub_calc,
                explanation=f"Verschachtelte Berechnung: {sub_calc.name}"
            )

            # Argument 2: arg3
            if calc.argument3 or calc.argument3_value is not None:
                ConsumptionCalcArgument.objects.create(
                    consumption_calc=calc,
                    position=2,
                    meter_place=calc.argument3,
                    value=calc.argument3_value,
                    unit=calc.argument3_unit or '',
                    explanation=calc.argument3_explanation or ''
                )
        else:
            # Fall: 1-2 Argumente -> Normale Migration
            position = 1

            # Bestimme den Operator
            if calc.operator1 and calc.operator1 != ' ':
                calc.operator = calc.operator1
            elif calc.operator2 and calc.operator2 != ' ':
                calc.operator = calc.operator2
            else:
                calc.operator = '+'
            calc.save(update_fields=['operator'])

            # Argument 1
            if calc.argument1 or calc.argument1_value is not None:
                ConsumptionCalcArgument.objects.create(
                    consumption_calc=calc,
                    position=position,
                    meter_place=calc.argument1,
                    value=calc.argument1_value,
                    unit=calc.argument1_unit or '',
                    explanation=calc.argument1_explanation or ''
                )
                position += 1

            # Argument 2
            if calc.argument2 or calc.argument2_value is not None:
                ConsumptionCalcArgument.objects.create(
                    consumption_calc=calc,
                    position=position,
                    meter_place=calc.argument2,
                    value=calc.argument2_value,
                    unit=calc.argument2_unit or '',
                    explanation=calc.argument2_explanation or ''
                )
                position += 1


def migrate_arguments_backward(apps, schema_editor):
    """Rollback: Kopiert die ersten 3 Arguments zurück in die alten Felder"""
    ConsumptionCalc = apps.get_model('bill', 'ConsumptionCalc')
    ConsumptionCalcArgument = apps.get_model('bill', 'ConsumptionCalcArgument')

    for calc in ConsumptionCalc.objects.all():
        arguments = list(ConsumptionCalcArgument.objects.filter(
            consumption_calc=calc
        ).order_by('position')[:3])

        if len(arguments) >= 1:
            arg = arguments[0]
            calc.argument1 = arg.meter_place
            calc.argument1_value = arg.value
            calc.argument1_unit = arg.unit
            calc.argument1_explanation = arg.explanation

        if len(arguments) >= 2:
            arg = arguments[1]
            calc.argument2 = arg.meter_place
            calc.argument2_value = arg.value
            calc.argument2_unit = arg.unit
            calc.argument2_explanation = arg.explanation
            calc.operator1 = calc.operator

        if len(arguments) >= 3:
            arg = arguments[2]
            calc.argument3 = arg.meter_place
            calc.argument3_value = arg.value
            calc.argument3_unit = arg.unit
            calc.argument3_explanation = arg.explanation
            calc.operator2 = calc.operator

        calc.save()

        # Lösche die Arguments
        ConsumptionCalcArgument.objects.filter(consumption_calc=calc).delete()


class Migration(migrations.Migration):

    dependencies = [
        ('bill', '0006_consumptioncalc_operator_and_more'),
    ]

    operations = [
        migrations.RunPython(migrate_arguments_forward,
                             migrate_arguments_backward),
    ]
